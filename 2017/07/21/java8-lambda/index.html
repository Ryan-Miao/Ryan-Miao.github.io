<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java8学习(3)- Lambda 表达式 | Ryan Miao的博客</title><meta name="keywords" content="Java8,Lambda"><meta name="author" content="Ryan Miao"><meta name="copyright" content="Ryan Miao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="猪脚：以下内容参考《Java 8 in Action》  本次学习内容：   Lambda 基本模式 环绕执行模式 函数式接口，类型推断 方法引用 Lambda 复合       代码： https:&#x2F;&#x2F;github.com&#x2F;Ryan-Miao&#x2F;someTest&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;test&#x2F;java8&#x2F;c3&#x2F;AppleSort.java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8学习(3)- Lambda 表达式">
<meta property="og:url" content="http://blog.rmiao.top/2017/07/21/java8-lambda/index.html">
<meta property="og:site_name" content="Ryan Miao的博客">
<meta property="og:description" content="猪脚：以下内容参考《Java 8 in Action》  本次学习内容：   Lambda 基本模式 环绕执行模式 函数式接口，类型推断 方法引用 Lambda 复合       代码： https:&#x2F;&#x2F;github.com&#x2F;Ryan-Miao&#x2F;someTest&#x2F;blob&#x2F;master&#x2F;src&#x2F;main&#x2F;java&#x2F;com&#x2F;test&#x2F;java8&#x2F;c3&#x2F;AppleSort.java">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg">
<meta property="article:published_time" content="2017-07-21T04:52:27.000Z">
<meta property="article:modified_time" content="2020-11-10T13:25:51.140Z">
<meta property="article:author" content="Ryan Miao">
<meta property="article:tag" content="Java8">
<meta property="article:tag" content="Lambda">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.rmiao.top/2017/07/21/java8-lambda/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-11-10 21:25:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">92</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">60</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">42</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ryan Miao的博客</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">Java8学习(3)- Lambda 表达式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2017-07-21T04:52:27.000Z" title="Created 2017-07-21 12:52:27">2017-07-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2020-11-10T13:25:51.140Z" title="Updated 2020-11-10 21:25:51">2020-11-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java8/">Java8</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>猪脚：以下内容参考《Java 8 in Action》</p>
</blockquote>
<p>本次学习内容：</p>
<blockquote>
<ul>
<li>Lambda 基本模式</li>
<li>环绕执行模式</li>
<li>函数式接口，类型推断</li>
<li>方法引用</li>
<li>Lambda 复合    </li>
</ul>
</blockquote>
<p>代码： <a target="_blank" rel="noopener" href="https://github.com/Ryan-Miao/someTest/blob/master/src/main/java/com/test/java8/c3/AppleSort.java">https://github.com/Ryan-Miao/someTest/blob/master/src/main/java/com/test/java8/c3/AppleSort.java</a></p>
<a id="more"></a>

<h2 id="上一篇Java8学习-2-通过行为参数化传递代码–lambda代替策略模式"><a href="#上一篇Java8学习-2-通过行为参数化传递代码–lambda代替策略模式" class="headerlink" title="上一篇Java8学习(2)- 通过行为参数化传递代码–lambda代替策略模式"></a>上一篇<a target="_blank" rel="noopener" href="http://ryan-miao.oschina.io/2017/07/15/java8-in-action-2/">Java8学习(2)- 通过行为参数化传递代码–lambda代替策略模式</a></h2><h1 id="1-结构"><a href="#1-结构" class="headerlink" title="1. 结构"></a>1. 结构</h1><p>初始化一个比较器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Apple&gt; byWeight = <span class="keyword">new</span> Comparator&lt;Apple&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">copare</span><span class="params">(Apple a1, Apple a2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a1.getWeight().compareTo(a2.getWeight() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Apple&gt; byWeight = (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight() );</span><br></pre></td></tr></table></figure>
<p><img src="http://oe20lp6p0.bkt.clouddn.com/blog/2017/lambdalambda.png"></p>
<ul>
<li>参数列表–compare方法的的两个参数</li>
<li>箭头 — 把参数列表与lambda主体分割开</li>
<li>Lambda主体 — 表达式的值就是Lambda的返回值</li>
</ul>
<h2 id="1-1-Java8中有效的Lambda表达式"><a href="#1-1-Java8中有效的Lambda表达式" class="headerlink" title="1.1 Java8中有效的Lambda表达式"></a>1.1 Java8中有效的Lambda表达式</h2><p>接收一个字符串，并返回字符串长度int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(String a) -&gt; s.length()</span><br></pre></td></tr></table></figure>

<p>接收一个Apple类参数，返回一个boolean值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Apple a) -&gt; a.getWeight() &gt; <span class="number">150</span></span><br></pre></td></tr></table></figure>

<p>接收两个参数，没有返回值(void)，多行语句需要用大括号包围</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Result:&quot;</span>);</span><br><span class="line">    System.out.println(x + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不接收参数，返回一个值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()-&gt; <span class="number">42</span></span><br></pre></td></tr></table></figure>

<p>接收两个参数，返回一个值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight() );</span><br></pre></td></tr></table></figure>


<h2 id="1-2-Lambda的基本语法"><a href="#1-2-Lambda的基本语法" class="headerlink" title="1.2 Lambda的基本语法"></a>1.2 Lambda的基本语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt; &#123;statements&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h1 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h1><p>在上次的学习中的<a target="_blank" rel="noopener" href="http://ryan-miao.oschina.io/2017/07/15/java8-in-action-2/">通过行为参数化传递代码</a>, <code>Predicate(T)</code>就是一个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数式接口</strong>就是只定义一个抽象方法的接口。<br>Java API中很多符合这个条件。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-函数式接口可以做什么"><a href="#2-1-函数式接口可以做什么" class="headerlink" title="2.1 函数式接口可以做什么"></a>2.1 函数式接口可以做什么</h2><p>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，<strong>并把表达式作为函数式接口的实例</strong>（函数式接口一个具体实现的实例）。就像内部类一样，但看起来比内部类简洁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Runnable r2 = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">process(r1);</span><br><span class="line">process(r2);</span><br><span class="line">process(() -&gt; System.out.println(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p><code>@FunctionalInterface</code>是一个标注，用来告诉编译器这是一个函数式接口，如果不满足函数式接口的条件，编译器就会报错。当然，这不是必须的。好处是编译器帮助检查问题。</p>
<h1 id="3-一步步修改为Lambda表达式"><a href="#3-一步步修改为Lambda表达式" class="headerlink" title="3. 一步步修改为Lambda表达式"></a>3. 一步步修改为Lambda表达式</h1><p>Lambda式提供了传递方法的能力。这种能力首先可以用来处理样板代码。比如JDBC连接，比如file读写。这些操作会有try-catcha-finally，但我们更关心的是中间的部分。那么，是不是可以将中间的部分提取出来，当做参数传递进来？</p>
<h2 id="3-1-第1步：-行为参数化"><a href="#3-1-第1步：-行为参数化" class="headerlink" title="3.1 第1步： 行为参数化"></a>3.1 第1步： 行为参数化</h2><p>下面是读一行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;data.txt&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://oe20lp6p0.bkt.clouddn.com/blog/2017/lambda-readlambda-read.png"></p>
<p>行为参数化就是把一个过程行为转换成参数。在这里就是将<code>br.readLine()</code>提取成参数。</p>
<h2 id="3-2-第2步：使用函数式接口来传递行为"><a href="#3-2-第2步：使用函数式接口来传递行为" class="headerlink" title="3.2 第2步：使用函数式接口来传递行为"></a>3.2 第2步：使用函数式接口来传递行为</h2><p>定义一个接口来执行上述的行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BufferedReaderProcessor</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(BufferedReader b)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把这个接口当作参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">(BufferedReaderProcessor p)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>(BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;data.txt&quot;</span>)))&#123;</span><br><span class="line">        <span class="keyword">return</span> p.process(br);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-第3步：-传递Lambda"><a href="#3-3-第3步：-传递Lambda" class="headerlink" title="3.3 第3步： 传递Lambda"></a>3.3 第3步： 传递Lambda</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String oneLine = read(BufferedReader::readLine);</span><br><span class="line">    String twoLine = read((BufferedReader b) -&gt; b.readLine() + b.readLine());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，我们就把中间的逻辑抽出来了。把行为抽象成一个接口调用，然后通过Lambda来实现接口的行为。传递参数。完毕。</p>
<h1 id="4-Java-API中内置的一些函数式接口"><a href="#4-Java-API中内置的一些函数式接口" class="headerlink" title="4. Java API中内置的一些函数式接口"></a>4. Java API中内置的一些函数式接口</h1><p>Java API中内置了一些很有用的Function接口。</p>
<h2 id="4-1-Predicate"><a href="#4-1-Predicate" class="headerlink" title="4.1 Predicate"></a>4.1 Predicate</h2><p><strong><code>java.util.function.Predicate&lt;T&gt; </code>定义了一个抽象方法，返回一个<code>boolean</code>。</strong><br>使用demo如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt;  <span class="function">List&lt;T&gt; <span class="title">filter</span><span class="params">(List&lt;T&gt; list, Predicate&lt;T&gt; p)</span></span>&#123;</span><br><span class="line">    List&lt;T&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.test(t))&#123;</span><br><span class="line">            results.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPredicate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bbb&quot;</span>,<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">    List&lt;String&gt; noEmpty = filter(list, (String s) -&gt; !s.isEmpty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-Consuer"><a href="#4-2-Consuer" class="headerlink" title="4.2 Consuer"></a>4.2 Consuer</h2><p><strong><code>java.util.function.Consumer&lt;T&gt;</code>定义了一个抽象方法，接收一个参数。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(List&lt;T&gt; list, Consumer&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">        c.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    forEach(integers, System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-Function"><a href="#4-3-Function" class="headerlink" title="4.3 Function"></a>4.3 Function</h2><p>**<code>java.util.function.Function&lt;T,R&gt;</code>**定义了一个抽象方法，接收一个参数<code>T</code>，返回一个对象<code>R</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T,R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list, Function&lt;T,R&gt; f)</span></span>&#123;</span><br><span class="line">    List&lt;R&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (T t : list) &#123;</span><br><span class="line">        result.add(f.apply(t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">    List&lt;Integer&gt; lengths = map(strings, String::length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-基本类型函数接口"><a href="#4-4-基本类型函数接口" class="headerlink" title="4.4 基本类型函数接口"></a>4.4 基本类型函数接口</h2><p>前面三个泛型函数式接口<code>Predicate&lt;T&gt;</code>、<code>Consumer&lt;T&gt;</code>、<code>Function&lt;T,R&gt;</code>，这些接口是专门为引用类型设计的。那么基本类型怎么办？我们知道可以自动装箱嘛。但装箱是有损耗的。装箱(boxing)的本质是把原始类型包裹起来，并保存在堆里。因此装箱后的值需要更多的内存，并需要额外的内存搜索来获取包裹的原始值。</p>
<p>Java8为函数式接口带来了专门的版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntPredicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//无装箱</span></span><br><span class="line">    IntPredicate intPredicate = (<span class="keyword">int</span> t) -&gt; t%<span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isEven = intPredicate.test(<span class="number">100</span>);</span><br><span class="line">    Assert.assertTrue(isEven);</span><br><span class="line">    <span class="comment">//装箱</span></span><br><span class="line">    Predicate&lt;Integer&gt; integerPredicate = (Integer i) -&gt; i%<span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isEven2 = integerPredicate.test(<span class="number">100</span>);</span><br><span class="line">    Assert.assertTrue(isEven2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的还有:</p>
<p>Java 8中的常用函数式接口<br><img src="http://oe20lp6p0.bkt.clouddn.com/blog/2017/java-function-1.png"><br><img src="http://oe20lp6p0.bkt.clouddn.com/blog/2017/java-function2.png"></p>
<h1 id="5-Lambda原理"><a href="#5-Lambda原理" class="headerlink" title="5. Lambda原理"></a>5. Lambda原理</h1><ul>
<li>编译器可以推断出方法的参数类型，由此可以省略一些样板代码。</li>
<li>void和其他返回值做了兼容性处理</li>
</ul>
<h1 id="6-Lambda的局部变量"><a href="#6-Lambda的局部变量" class="headerlink" title="6. Lambda的局部变量"></a>6. Lambda的局部变量</h1><p>在Lambda中可以使用局部变量，但要求必须是final的。因为Lambda可能在另一个线程中运行，而局部变量是在栈上的，Lambda作为额外的线程会拷贝一份变量副本。这样可能会出现同步问题，因为主线程的局部变量或许已经被回收了。基于此，必须要求final的。</p>
<p>而实例变量则没问题，因为实例变量存储于堆中，堆是共享的。</p>
<h1 id="7-方法引用"><a href="#7-方法引用" class="headerlink" title="7. 方法引用"></a>7. 方法引用</h1><p>Lambda表达式可以用方法引用来表示。比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(String s) -&gt; s.length()</span><br><span class="line">==</span><br><span class="line">String::length</span><br></pre></td></tr></table></figure>
<p>这是因为可以通过Lambda表达式的参数以及方法来确定一个方法。在这里，每个方法都叫做<code>方法签名</code>。方法签名由<strong>方法名+参数列表</strong>唯一确定。其实就是重载的判断方式。</p>
<p>当Lambda的主体只是一个简单的方法调用的时候，我们可以直接使用一个方法引用来代替。方法引用可以知道要接受的参数类型，以及方法体的逻辑。</p>
<p>方法引用结构：<br><code>类名::方法名</code>  </p>
<p>什么可以使用方法引用？</p>
<ul>
<li>静态方法。   </li>
<li>指向任意类型实例方法的方法引用。  </li>
<li>指向现有对象的实例方法。</li>
</ul>
<h1 id="8-构造函数引用"><a href="#8-构造函数引用" class="headerlink" title="8. 构造函数引用"></a>8. 构造函数引用</h1><p>构造函数可以通过<code>类名::new</code>的方式引用。</p>
<h1 id="9-Lambda实战"><a href="#9-Lambda实战" class="headerlink" title="9. Lambda实战"></a>9. Lambda实战</h1><p>目标： 用不同的排序策略给apple排序。<br>过程： 把一个原始粗暴的解决方案变得更加简单。<br>资料： <code>行为参数化</code>, <code>匿名类</code>，<code>Lambda</code>, <code>方法引用</code>.<br>最终： <code>inventory.sort(comparing(Apple::getWeight) );</code>    </p>
<h2 id="9-1-原始方案"><a href="#9-1-原始方案" class="headerlink" title="9.1 原始方案"></a>9.1 原始方案</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by ryan on 7/20/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Apple&gt; inventory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inventory = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inventory.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">1</span>));</span><br><span class="line">        inventory.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        inventory.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">2</span>));</span><br><span class="line">        inventory.add(<span class="keyword">new</span> Apple(<span class="string">&quot;red&quot;</span>, <span class="number">21</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort_old</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collections.sort(inventory, <span class="keyword">new</span> Comparator&lt;Apple&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getWeight() - o2.getWeight();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        printApples();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printApples</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inventory.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排序首先要注意的一点就是排序的标准。那么要搞清楚为什么这样写？  </p>
<p>Comparator定义的其实就是一个方法，此处就是将排序的原则抽取出来。特别符合Lambda的思想！这里先不说Lambda，先说这个方法的作用：<strong>定义什么时候发生交换</strong>。<br>跟踪源码可以发现这样一段代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java.util.Arrays#mergeSort(java.lang.Object[], java.lang.Object[], int, int, int, java.util.Comparator)</span></span><br><span class="line"><span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp; c.compare(dest[j-<span class="number">1</span>], dest[j])&gt;<span class="number">0</span>; j--)</span><br><span class="line">            swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设比较的两个数为<code>o1</code>和<code>o2</code>，并且<code>o1</code>在<code>o2</code>前一位(left&gt;right)。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">....o1,o2...</span><br></pre></td></tr></table></figure>

<p><code>compare(o1,o2)</code>的结果大于0则，<code>o1</code>和<code>o2</code>交换。那么，显然，如果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compare(o1,o2) = o1-o2</span><br></pre></td></tr></table></figure>
<p>则说明，前一个值比后一个值大的时候，发生交换。也即大的往后冒泡。就是升序了。<br>所以：     </p>
<ul>
<li><code>o1-o2</code> 升序</li>
<li><code>o2-o1</code> 降序</li>
</ul>
<h2 id="9-2-使用List内置sort"><a href="#9-2-使用List内置sort" class="headerlink" title="9.2 使用List内置sort"></a>9.2 使用List内置sort</h2><p>好消息是Java8提供了sort方法给list：<code>java.util.List#sort</code>:<br>则原始方案转换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    inventory.sort(<span class="keyword">new</span> Comparator&lt;Apple&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Apple o1, Apple o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getWeight() - o2.getWeight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    printApples();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-3-Lambda表达式代替匿名内部类"><a href="#9-3-Lambda表达式代替匿名内部类" class="headerlink" title="9.3 Lambda表达式代替匿名内部类"></a>9.3 Lambda表达式代替匿名内部类</h2><p>从之前的学习可以得到，几乎所有的匿名内部类都可以用Lambda表达式替代！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort((o1, o2) -&gt; o1.getWeight() - o2.getWeight());</span><br></pre></td></tr></table></figure>

<h2 id="9-4-进一步优化Lambda"><a href="#9-4-进一步优化Lambda" class="headerlink" title="9.4 进一步优化Lambda"></a>9.4 进一步优化Lambda</h2><p><code>Comparator</code>提供了一个生成Comparator的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U extends Comparable&lt;? <span class="keyword">super</span> U&gt;&gt; <span class="function">Comparator&lt;T&gt; <span class="title">comparing</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; keyExtractor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Objects.requireNonNull(keyExtractor);</span><br><span class="line">    <span class="keyword">return</span> (Comparator&lt;T&gt; &amp; Serializable)</span><br><span class="line">        (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>Function&lt;T,R&gt;</code>已经在前面学习过了，就是一个接受一个参数并返回另一个参数的函数式接口。在本例中，<code>apple.getWeight()</code>符合接受一个参数<code>apple</code>返回一个<code>int</code>。那么，就可以使用这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(Comparator.comparing((Apple a)-&gt;a.getWeight()));</span><br></pre></td></tr></table></figure>
<p>进一步，将Lambda改为方法引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(Comparator.comparing(Apple::getWeight));</span><br></pre></td></tr></table></figure>
<p>这里有个问题，记得之前讲的基本类型的自动装箱吗。<code>Apple::getWeight</code>的返回值是<code>int</code>。而<code>comparing</code>的返回值是一个对象。那么，必然要经过自动装箱的过程。所以，应该使用基本类型的函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(Comparator.comparingInt(Apple::getWeight));</span><br></pre></td></tr></table></figure>
<p>至此，基本已经改造完毕了。最多就是静态引入<code>comparingInt</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(comparingInt(Apple::getWeight));</span><br></pre></td></tr></table></figure>
<p>目标达到。相比原始方法，不要太简洁！</p>
<p>话说，这种是不是只能默认升序？因此没有任何一个单词可以看出排序规则。</p>
<p>是的，想要降序？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(comparingInt(Apple::getWeight).reversed());</span><br></pre></td></tr></table></figure>




<h1 id="10-复合Lambda"><a href="#10-复合Lambda" class="headerlink" title="10 复合Lambda"></a>10 复合Lambda</h1><p>上节看到逆序的方法就是后面追加一个逆序的方法。现在需求变更了。需要先按照颜色排序，然后再按照重量从大到小排序。</p>
<h2 id="10-1-比较器链"><a href="#10-1-比较器链" class="headerlink" title="10.1 比较器链"></a>10.1 比较器链</h2><p>这里，一共涉及了3个过程。往常的做法是连续写在一个方法里，或者3个方法连续调用。Lambda提供了类似语句陈述一般的写法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(comparing(Apple::getColor)</span><br><span class="line">       .reversed()</span><br><span class="line">       .thenComparingInt(Apple::getWeight));</span><br></pre></td></tr></table></figure>


<h2 id="10-2-谓词复合"><a href="#10-2-谓词复合" class="headerlink" title="10.2 谓词复合"></a>10.2 谓词复合</h2><p>前面的<code>Prediacate</code>接口包含4个方法：<code>negate</code>,<code>and</code>,<code>or</code>，<code>isEqual</code>，对应逻辑运算里的<code>取反</code>,<code>且</code>,<code>或</code>,<code>==</code>。这样，通过复合就可以写出语义声明式的代码：</p>
<p>想要红苹果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; red = apple -&gt; <span class="string">&quot;red&quot;</span>.equalsIgnoreCase(apple.getColor());</span><br></pre></td></tr></table></figure>
<p>想要不是红的苹果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; nonRed = red.negate();</span><br></pre></td></tr></table></figure>
<p>想要大的红苹果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; redAndHeavy = red.and(apple -&gt; apple.getWeight() &gt; <span class="number">150</span>);</span><br></pre></td></tr></table></figure>
<p>想要大的红苹果或者绿色的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; redAndHeavyOrGreen = redAndHeavy.or(apple -&gt; <span class="string">&quot;green&quot;</span>.equalsIgnoreCase(apple.getColor()));</span><br><span class="line">或者：</span><br><span class="line">redAndHeavyOrGreen = ((Predicate&lt;Apple&gt;) apple -&gt; <span class="string">&quot;red&quot;</span>.equalsIgnoreCase(apple.getColor()))</span><br><span class="line">                .and(apple -&gt; apple.getWeight() &gt; <span class="number">150</span>)</span><br><span class="line">                .or(apple -&gt; <span class="string">&quot;green&quot;</span>.equalsIgnoreCase(apple.getColor()));</span><br></pre></td></tr></table></figure>


<h2 id="10-3-函数复合"><a href="#10-3-函数复合" class="headerlink" title="10.3 函数复合"></a>10.3 函数复合</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(x) &#x3D; (x+1) * 2;</span><br><span class="line">求 f(2)</span><br></pre></td></tr></table></figure>
<p>普通写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Assert.assertEquals(<span class="number">6</span>, f(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x +<span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.andThen(g);</span><br><span class="line"><span class="keyword">int</span> r = h.apply(<span class="number">2</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">6</span>, r);</span><br></pre></td></tr></table></figure>
<p>看起来似乎更麻烦了，但这只是一个举例。事实上，Function提供了连续处理逻辑的能力，可以不断的处理上一次计算的返回值。</p>
<p>比如，封装一个写信的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Letter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addHeader</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;From Ryan Miao: &quot;</span> + text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">addFooter</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text + <span class="string">&quot; Kind regards&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">checkSpelling</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text.replace(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&amp;lt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunction3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Function&lt;String, String&gt; transformationPipeline =</span><br><span class="line">            ((Function&lt;String, String&gt;)Letter::addHeader)</span><br><span class="line">                    .andThen(Letter::checkSpelling)</span><br><span class="line">                    .andThen(Letter::addFooter);</span><br><span class="line">    String letter = transformationPipeline.apply(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    Assert.assertEquals(<span class="string">&quot;From Ryan Miao: Hello world! Kind regards&quot;</span>, letter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






<hr>
<h1 id="11-小结"><a href="#11-小结" class="headerlink" title="11 小结"></a>11 小结</h1><ul>
<li><strong>Lambda表达式可以理解为一种匿名函数</strong>：它没有名称，但有参数列表、函数主题、返回值类型，可能还有一个可以抛出的异常列表。</li>
<li>Lambda表达式让你可以更简洁的<strong>传递代码</strong>。</li>
<li>函数式接口就是仅仅声明了<strong>一个抽象方法</strong>的接口。</li>
<li>只有在接受函数式接口的地方才可以使用Lambda表达式。</li>
<li>Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且<strong>将整个表达式作为函数式接口的一个实例</strong>。</li>
<li>Java 8自带了一些常用函数式接口，放在<code>java.util.function</code>里。包括<code>Prediacate&lt;T&gt;</code>,<code>Function&lt;T,R&gt;</code>,<code>Supplier&lt;T&gt;</code>,<code>Consumer&lt;T&gt;</code>,<code>BinaryOperator&lt;T&gt;</code>。</li>
<li>为了避免装箱操作，对Predicate<T>和Function&lt;T,R&gt;等通用函数式接口的原始类特殊化：IntPredicate,InToLong等。</li>
<li>环绕执行模式（方法的中间代码）可以配合Lambda提高灵活性和可重用性。</li>
<li>Lambda表达式所需要代表的类型成为目标类型。</li>
<li>Comparator,Predicate,Function等函数接口都有几个可以用来结合Lambda表达式的默认方法。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Ryan Miao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://blog.rmiao.top/2017/07/21/java8-lambda/">http://blog.rmiao.top/2017/07/21/java8-lambda/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java8/">Java8</a><a class="post-meta__tags" href="/tags/Lambda/">Lambda</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2017/07/23/js-cros/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">js-cros</div></div></a></div><div class="next-post pull-right"><a href="/2017/07/19/git-rebase/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">git合并历史提交</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2017/07/15/java8-in-action-2/" title="Java8学习(2)-  通过行为参数化传递代码--lambda代替策略模式"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-07-15</div><div class="title">Java8学习(2)-  通过行为参数化传递代码--lambda代替策略模式</div></div></a></div><div><a href="/2018/04/04/Java8-build-stream/" title="Java8-如何构建一个Stream"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-04-04</div><div class="title">Java8-如何构建一个Stream</div></div></a></div><div><a href="/2018/04/11/java-list-distinct/" title="Java中对List去重, Stream去重"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-04-11</div><div class="title">Java中对List去重, Stream去重</div></div></a></div><div><a href="/2018/01/10/java-optional-usage-note/" title="Java中Optional使用注意事项"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-01-10</div><div class="title">Java中Optional使用注意事项</div></div></a></div><div><a href="/2018/04/22/java8-customize-collector/" title="Java8-理解Collector"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-04-22</div><div class="title">Java8-理解Collector</div></div></a></div><div><a href="/2018/05/29/java8-date-api/" title="Java8新的日期API"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-05-29</div><div class="title">Java8新的日期API</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Ryan Miao</div><div class="author-info__description">技术总结</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">92</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">60</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">42</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ryan-miao" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:woshimrf@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%80%E7%AF%87Java8%E5%AD%A6%E4%B9%A0-2-%E9%80%9A%E8%BF%87%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96%E4%BC%A0%E9%80%92%E4%BB%A3%E7%A0%81%E2%80%93lambda%E4%BB%A3%E6%9B%BF%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">上一篇Java8学习(2)- 通过行为参数化传递代码–lambda代替策略模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E7%BB%93%E6%9E%84"><span class="toc-number"></span> <span class="toc-text">1. 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Java8%E4%B8%AD%E6%9C%89%E6%95%88%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">1.1 Java8中有效的Lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Lambda%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">1.2 Lambda的基本语法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number"></span> <span class="toc-text">2. 函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">2.1 函数式接口可以做什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%B8%80%E6%AD%A5%E6%AD%A5%E4%BF%AE%E6%94%B9%E4%B8%BALambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">3. 一步步修改为Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E7%AC%AC1%E6%AD%A5%EF%BC%9A-%E8%A1%8C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">3.1 第1步： 行为参数化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E7%AC%AC2%E6%AD%A5%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E6%9D%A5%E4%BC%A0%E9%80%92%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.</span> <span class="toc-text">3.2 第2步：使用函数式接口来传递行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%AC%AC3%E6%AD%A5%EF%BC%9A-%E4%BC%A0%E9%80%92Lambda"><span class="toc-number">3.</span> <span class="toc-text">3.3 第3步： 传递Lambda</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Java-API%E4%B8%AD%E5%86%85%E7%BD%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number"></span> <span class="toc-text">4. Java API中内置的一些函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Predicate"><span class="toc-number">1.</span> <span class="toc-text">4.1 Predicate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Consuer"><span class="toc-number">2.</span> <span class="toc-text">4.2 Consuer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Function"><span class="toc-number">3.</span> <span class="toc-text">4.3 Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.</span> <span class="toc-text">4.4 基本类型函数接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Lambda%E5%8E%9F%E7%90%86"><span class="toc-number"></span> <span class="toc-text">5. Lambda原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Lambda%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number"></span> <span class="toc-text">6. Lambda的局部变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">7. 方法引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8"><span class="toc-number"></span> <span class="toc-text">8. 构造函数引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Lambda%E5%AE%9E%E6%88%98"><span class="toc-number"></span> <span class="toc-text">9. Lambda实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%8E%9F%E5%A7%8B%E6%96%B9%E6%A1%88"><span class="toc-number">1.</span> <span class="toc-text">9.1 原始方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E4%BD%BF%E7%94%A8List%E5%86%85%E7%BD%AEsort"><span class="toc-number">2.</span> <span class="toc-text">9.2 使用List内置sort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BB%A3%E6%9B%BF%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">9.3 Lambda表达式代替匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96Lambda"><span class="toc-number">4.</span> <span class="toc-text">9.4 进一步优化Lambda</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%A4%8D%E5%90%88Lambda"><span class="toc-number"></span> <span class="toc-text">10 复合Lambda</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%AF%94%E8%BE%83%E5%99%A8%E9%93%BE"><span class="toc-number">1.</span> <span class="toc-text">10.1 比较器链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E8%B0%93%E8%AF%8D%E5%A4%8D%E5%90%88"><span class="toc-number">2.</span> <span class="toc-text">10.2 谓词复合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E5%87%BD%E6%95%B0%E5%A4%8D%E5%90%88"><span class="toc-number">3.</span> <span class="toc-text">10.3 函数复合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E5%B0%8F%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">11 小结</span></a></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/11/11/java-synchronized/" title="Java基础之Synchronized原理"><img src="https://cn.bing.com/th?id=OHR.EsskastanieD_ZH-CN9736686128_UHD.jpg&amp;rf=LaDigue_UHD.jpg&amp;pid=hp&amp;w=2880&amp;h=1620&amp;rs=1&amp;c=4" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础之Synchronized原理"/></a><div class="content"><a class="title" href="/2020/11/11/java-synchronized/" title="Java基础之Synchronized原理">Java基础之Synchronized原理</a><time datetime="2020-11-11T12:46:40.000Z" title="Created 2020-11-11 20:46:40">2020-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2018/07/10/java-class-inheritance/" title="Java复习3-类的继承"><img src="https://cn.bing.com/th?id=OHR.LakotaBadlands_ZH-CN0151830089_UHD.jpg&amp;rf=LaDigue_UHD.jpg&amp;pid=hp&amp;w=2880&amp;h=1620&amp;rs=1&amp;c=4" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java复习3-类的继承"/></a><div class="content"><a class="title" href="/2018/07/10/java-class-inheritance/" title="Java复习3-类的继承">Java复习3-类的继承</a><time datetime="2018-07-10T11:58:14.000Z" title="Created 2018-07-10 19:58:14">2018-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2018/07/07/java-class/" title="Java复习2-对象与类"><img src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java复习2-对象与类"/></a><div class="content"><a class="title" href="/2018/07/07/java-class/" title="Java复习2-对象与类">Java复习2-对象与类</a><time datetime="2018-07-07T07:27:14.000Z" title="Created 2018-07-07 15:27:14">2018-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2018/07/06/java-data-type/" title="Java复习1-数据类型"><img src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java复习1-数据类型"/></a><div class="content"><a class="title" href="/2018/07/06/java-data-type/" title="Java复习1-数据类型">Java复习1-数据类型</a><time datetime="2018-07-06T09:03:26.000Z" title="Created 2018-07-06 17:03:26">2018-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2018/07/04/springcloud-consumer/" title="SpringCloud学习6-如何创建一个服务消费者consumer"><img src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloud学习6-如何创建一个服务消费者consumer"/></a><div class="content"><a class="title" href="/2018/07/04/springcloud-consumer/" title="SpringCloud学习6-如何创建一个服务消费者consumer">SpringCloud学习6-如何创建一个服务消费者consumer</a><time datetime="2018-07-04T11:44:12.000Z" title="Created 2018-07-04 19:44:12">2018-07-04</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By Ryan Miao</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: '50b74dddd9c8deff00e9',
      clientSecret: 'b61654c092fbd8ab7ff6c4d0078b671b62211e23',
      repo: 'gitalk',
      owner: 'ryanmiao2',
      admin: ['ryanmiao2'],
      id: '847dd5068031ca934d985939c21588f7',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    $.getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js', initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>