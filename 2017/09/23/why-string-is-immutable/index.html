<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>String的内存模型，为什么String被设计成不可变的 | Ryan Miao的博客</title><meta name="keywords" content="Java"><meta name="author" content="Ryan Miao"><meta name="copyright" content="Ryan Miao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="String是Java中最常用的类，是不可变的(Immutable), 那么String是如何实现Immutable呢，String为什么要设计成不可变呢？"><meta property="og:type" content="article"><meta property="og:title" content="String的内存模型，为什么String被设计成不可变的"><meta property="og:url" content="http://blog.rmiao.top/2017/09/23/why-string-is-immutable/index.html"><meta property="og:site_name" content="Ryan Miao的博客"><meta property="og:description" content="String是Java中最常用的类，是不可变的(Immutable), 那么String是如何实现Immutable呢，String为什么要设计成不可变呢？"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg"><meta property="article:published_time" content="2017-09-22T16:04:43.000Z"><meta property="article:modified_time" content="2020-11-10T13:25:51.152Z"><meta property="article:author" content="Ryan Miao"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://blog.rmiao.top/2017/09/23/why-string-is-immutable/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="maTgu7CiAQC-q4KDPYtjkPcCNliwRuCX8IuThKKIZzo"><meta name="baidu-site-verification" content="code-HNJaUItPgZ"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-9728761484167276",enable_page_level_ads:"true"})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?caff024b07e794f2b6ef044008b2acd3";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2020-11-10 21:25:51"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_2204177_honuy9aiklh.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">60</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">43</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ryan Miao的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">String的内存模型，为什么String被设计成不可变的</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2017-09-22T16:04:43.000Z" title="发表于 2017-09-23 00:04:43">2017-09-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-11-10T13:25:51.152Z" title="更新于 2020-11-10 21:25:51">2020-11-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>String是Java中最常用的类，是不可变的(Immutable), 那么String是如何实现Immutable呢，String为什么要设计成不可变呢？</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于String,收集一波基础，来源标明最后，不确定是否权威, 希望有问题可以得到纠正。</p><h1 id="0-String的内存模型"><a href="#0-String的内存模型" class="headerlink" title="0. String的内存模型"></a>0. String的内存模型</h1><ul><li>Java8以及以后的字符串新建时，直接在堆中生成对象，而字符创常量池位于Metaspace。必要的时候，会把堆中的指针存入Metaspace, 而不是复制。</li><li>Metaspace位于虚拟机以外的直接内存，因此大小和外部直接内存有关，但也可以通过指定参数设置<code>-XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</code></li></ul><p><img src="http://oe20lp6p0.bkt.clouddn.com/blog/2017/string/metaspace.png"></p><h2 id="0-1-一些真实测试，以及某些推测"><a href="#0-1-一些真实测试，以及某些推测" class="headerlink" title="0.1 一些真实测试，以及某些推测"></a>0.1 一些真实测试，以及某些推测</h2><p>很难直接从百度出的中文资料中得到确切的答案，因为大多以讹传讹，未经验证。这里且做测试，先记住，因为很不情愿啃官方文档。</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>首先，要有字符串常量池的概念。然后知道String是怎么和常量池打交道的。这里的武器就是<code>intern()</code>,看一下javadoc:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment">     * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment">     * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment">     * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment">     * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment">     * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment">     * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment">     * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment">     *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>即常量池存在，返回常量池中的那个对象，常量池不存在，则放入常量池，并返回本身。由此推断两个公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.intern() &#x3D;&#x3D; str &#x2F;&#x2F;证明返回this本身，证明常量池不存在。</span><br><span class="line">str.intern() !&#x3D; str &#x2F;&#x2F;证明返回常量池中已存在的对象，不等于新建的对象。</span><br></pre></td></tr></table></figure><h4 id="这两个公式有什么用"><a href="#这两个公式有什么用" class="headerlink" title="这两个公式有什么用?"></a>这两个公式有什么用?</h4><p>面试题虽然被很多牛人说low(<a target="_blank" rel="noopener" href="http://rednaxelafx.iteye.com/blog/774673">请别再拿“String s = new String(“xyz”);创建了多少个String实例”来面试了吧</a>)，但确实经常出现new String以及几个对象之类的问题。而这个问题主要是考察String的内存模型，连带可以引出对Java中对象的内存模型的理解。</p><p>通过判断上述两个公式，我们可以知道对象究竟是新建的，还是来自常量池，如此就可以坦然面对谁等于谁的问题。</p><h4 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h4><ul><li>为了准确表达，这里为伪地址表示指针位置，比如<code>0xab</code>表示”ab”这个对象的地址</li><li>测试基于jdk1.8.0_131.jdk</li><li>操作系统： MacOS 10.12.6</li><li>内存： 16G</li><li>CPU: 2.2 GHz Intel Core i7</li></ul><h4 id="Java-Visual-VM"><a href="#Java-Visual-VM" class="headerlink" title="Java Visual VM"></a>Java Visual VM</h4><p>JDK提供一个可视化内存查看工具<code>jvisualvm</code>。Mac由于安装Java后已经设置了环境变量，所以打开命令行，直接输入<code>jvisualvm</code>, 即可打开。Windows下应该是在bin目录下找到对应的exe文件，双击打开。</p><h4 id="OQL语言"><a href="#OQL语言" class="headerlink" title="OQL语言"></a>OQL语言</h4><p>在Java VisualVM中可以使用OQL来查找对象。具体可以查看<a target="_blank" rel="noopener" href="https://blogs.oracle.com/sundararajan/querying-java-heap-with-oql">Oracle博客</a>。百度出来的结果都是摘抄的[深入理解Java虚拟机]这本书附录里的内容。但我表示用来使用行不通。一些用法不一样。简单的归纳一些用的语法。</p><p>查询一个内容为<code>RyanMiao</code>的字符串:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#123;instance:s&#125; from java.lang.String s where s.toString() &#x3D;&#x3D; &quot;RyanMiao&quot;</span><br></pre></td></tr></table></figure><p>查询前缀为<code>Ryan</code>的字符串:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#123;instance:s&#125; from java.lang.String s where s.toString().substring(0,4) &#x3D;&#x3D;&quot;Ryan&quot;</span><br></pre></td></tr></table></figure><p>遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">filter(</span><br><span class="line">  sort(</span><br><span class="line">    map(heap.objects(&quot;java.lang.String&quot;),</span><br><span class="line">    function(heapString)&#123;</span><br><span class="line">      if( ! counts[heapString.toString()])&#123;</span><br><span class="line">        counts[heapString.toString()] &#x3D; 1;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        counts[heapString.toString()] &#x3D; counts[heapString.toString()] + 1;</span><br><span class="line">      &#125;</span><br><span class="line">      return &#123; string:heapString.toString(), count:counts[heapString.toString()]&#125;;</span><br><span class="line">    &#125;), </span><br><span class="line">    &#39;lhs.count &lt; rhs.count&#39;),</span><br><span class="line">  function(countObject) &#123;</span><br><span class="line">    if( countObject.string )&#123;</span><br><span class="line">      alreadyReturned[countObject.string] &#x3D; true;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>没找到匹配前缀的做法，这里使用最笨的遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filter(</span><br><span class="line">heap.objects(&quot;java.lang.String&quot;),</span><br><span class="line">function(str)&#123;</span><br><span class="line">  if(str !&#x3D; &quot;Ryan&quot; &amp;&amp; str !&#x3D;&quot;Miao&quot; &amp;&amp; str !&#x3D; &quot;RyanMiao&quot;)&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="0-1-1-通过-创建字符串"><a href="#0-1-1-通过-创建字符串" class="headerlink" title="0.1.1 通过=创建字符串"></a>0.1.1 通过<code>=</code>创建字符串</h3><p>通过<code>=</code>号创建对象，运行时只有一个对象存在。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ryan Miao</span></span><br><span class="line"><span class="comment"> * 等号赋值，注意字面量的存在</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNewStr</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//str.intern(): 若常量池存在，返回常量池中的对象；若常量池不存在，放入常量池，并返回this。</span></span><br><span class="line">    <span class="comment">//=号赋值，若常量池存在，直接返回常量池中的对象0xs1,如果常量池不存在，则放入常量池，常量池中的对象也是0xs1</span></span><br><span class="line">    String s1 = <span class="string">&quot;RyanMiao&quot;</span>;<span class="comment">//0xs1</span></span><br><span class="line">    Assert.assertTrue(s1.intern() == s1);<span class="comment">//0xs1 == 0xs1  &gt; true</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Java自带的工具Java VisualVM来查询内存中的String实例，可以看出s1只有一个对象。操作方法如下。</p><p>为了动态查看内存，选择休眠1h，run <code>testNewStr()</code>，然后打开jvisualvm, 可以看到几个vm列表，找到我们的vm，右键heamp dump.<br><img src="http://oe20lp6p0.bkt.clouddn.com/blog/2017/string/heapdump.png"></p><p>然后，选择右侧的OQL,在查询内容编辑框里输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#123;instance:s&#125; from java.lang.String s where s.toString() == <span class="string">&quot;RyanMiao&quot;</span></span><br></pre></td></tr></table></figure><p>可以发现，只有一个对象。<br><img src="http://oe20lp6p0.bkt.clouddn.com/blog/2017/string/string-euqal.png"></p><h3 id="0-1-2-通过new创建字符串"><a href="#0-1-2-通过new创建字符串" class="headerlink" title="0.1.2 通过new创建字符串"></a>0.1.2 通过<code>new</code>创建字符串</h3><p>通过new创建对象时，参数<code>RyanMiao</code>作为字面量会生成一个对象，并存入字符创常量池。而后，new的时候又将创建另一个String对象，所以，最好不要采用这种方式使用String, 不然就是双倍消耗内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ryan Miao</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 暴露的字面量(literal)也会生成对象，放入Metaspace</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNew</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//new赋值，直接堆中创建0xs2, 常量池中All literal strings and string-valued constant expressions are interned，</span></span><br><span class="line">    <span class="comment">// &quot;RyanMiao&quot;本身就是一个字符串，并放入常量池，故intern()返回0xab</span></span><br><span class="line">    String s2 = <span class="keyword">new</span> String(<span class="string">&quot;RyanMiao&quot;</span>);</span><br><span class="line">    Assert.assertFalse(s2.intern() == s2);<span class="comment">//0xRyanMiao == 0xs2  &gt; false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oe20lp6p0.bkt.clouddn.com/blog/2017/string/string-new.png"></p><h3 id="0-1-3-通过拼接创造字符串"><a href="#0-1-3-通过拼接创造字符串" class="headerlink" title="0.1.3 通过拼接创造字符串"></a>0.1.3 通过拼接创造字符串</h3><p>当字符创常量池不存在此对象的的时候，返回本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ryan Miao</span></span><br><span class="line"><span class="comment"> * 上栗中，由于字面量(literal)会生成对象，并放入常量池，因此可以直接从常量池中取出(前提是此行代码运行之前没有其他代码运行，常量池是干净的)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本次，测试非暴露字面量的str</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConcat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//没有任何字面量为&quot;RyanMiao&quot;暴露给编译器，所以常量池没有创建&quot;RyanMiao&quot;，所以，intern返回this</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;Ryan&quot;</span>).append(<span class="string">&quot;Miao&quot;</span>).toString();</span><br><span class="line">    Assert.assertTrue(s3.intern() == s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java Visual VM中，查询以”Ryan”开头的变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#123;instance:s&#125; from java.lang.String s where s.toString().substring(0,4) &#x3D;&#x3D;&quot;Ryan&quot;</span><br></pre></td></tr></table></figure><p>但，根据以上几个例子，可以明显看出来，字符串字面量(literal)都是对象，于是上栗中应该有三个对象:<code>Ryan</code>,<code>Miao</code>,<code>RyanMiao</code>。验证如下：<br><img src="http://oe20lp6p0.bkt.clouddn.com/blog/2017/string/ryanmiao.png"></p><p>此时的内存模型：<br><img src="http://oe20lp6p0.bkt.clouddn.com/blog/2017/string/string-struct.png"></p><h3 id="0-1-4-针对常量池中已存在的字符串"><a href="#0-1-4-针对常量池中已存在的字符串" class="headerlink" title="0.1.4 针对常量池中已存在的字符串"></a>0.1.4 针对常量池中已存在的字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ryan Miao</span></span><br><span class="line"><span class="comment"> * 上栗中，只要不暴露我们最终的字符串，常量池基本不会存在，则每次新建(new)的时候，都会放入常量池，intern并返回本身。即常量池的对象即新建的对象本身。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 本次，测试某些常量池已存在的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExist</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//为毛常量池存在java这个单词</span></span><br><span class="line">    <span class="comment">//s4 == 0xs4, intern发现常量池存在，返回0xexistjava</span></span><br><span class="line">    String s4 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line">    Assert.assertFalse(s4.intern() == s4);  <span class="comment">//0xexistjava == 0xs4  &gt; false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int也一开始就存在于常量池中了， intern返回0xexistint</span></span><br><span class="line">    String s5 = <span class="keyword">new</span> StringBuilder().append(<span class="string">&quot;in&quot;</span>).append(<span class="string">&quot;t&quot;</span>).toString();</span><br><span class="line">    Assert.assertFalse(s5.intern()==s5); <span class="comment">// 0xexistint == 0xs5  &gt; false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于字面量&quot;abc&quot;加载时，已放入常量池，故s6 intern返回0xexistabc, 而s6是新建的0xs6</span></span><br><span class="line">    String a = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s6 = <span class="keyword">new</span> StringBuilder().append(<span class="string">&quot;ab&quot;</span>).append(<span class="string">&quot;c&quot;</span>).toString();</span><br><span class="line">    Assert.assertFalse(s6.intern() == s6);  <span class="comment">//0xexistabc  == 0xs6 &gt; false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证如下:<br><img src="http://oe20lp6p0.bkt.clouddn.com/blog/2017/string/existstr.png"></p><p>使用命令行工具<code>javap -c TestString</code>可以反编译class，看到指令执行的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">% javap -c TestString</span><br><span class="line">Warning: Binary file TestString contains com.test.java.string.TestString</span><br><span class="line">Compiled from <span class="string">&quot;TestString.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">test</span>.<span class="title">java</span>.<span class="title">string</span>.<span class="title">TestString</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> com.test.java.string.TestString();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNewStr</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.InterruptedException</span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2                  // String RyanMiao</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: aload_1</span><br><span class="line">       4: invokevirtual #3                  // Method java/lang/String.intern:()Ljava/lang/String;</span><br><span class="line">       <span class="number">7</span>: aload_1</span><br><span class="line">       <span class="number">8</span>: if_acmpne     <span class="number">15</span></span><br><span class="line">      <span class="number">11</span>: iconst_1</span><br><span class="line">      <span class="number">12</span>: goto          <span class="number">16</span></span><br><span class="line">      <span class="number">15</span>: iconst_0</span><br><span class="line">      16: invokestatic  #4                  // Method org/junit/Assert.assertTrue:(Z)V</span><br><span class="line">      <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNew</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.InterruptedException</span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #5                  // class java/lang/String</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: ldc           #2                  // String RyanMiao</span><br><span class="line">       6: invokespecial #6                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">9</span>: astore_1</span><br><span class="line">      <span class="number">10</span>: aload_1</span><br><span class="line">      11: invokevirtual #3                  // Method java/lang/String.intern:()Ljava/lang/String;</span><br><span class="line">      <span class="number">14</span>: aload_1</span><br><span class="line">      <span class="number">15</span>: if_acmpne     <span class="number">22</span></span><br><span class="line">      <span class="number">18</span>: iconst_1</span><br><span class="line">      <span class="number">19</span>: goto          <span class="number">23</span></span><br><span class="line">      <span class="number">22</span>: iconst_0</span><br><span class="line">      23: invokestatic  #7                  // Method org/junit/Assert.assertFalse:(Z)V</span><br><span class="line">      <span class="number">26</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConcat</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.InterruptedException</span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #8                  // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: ldc           #9                  // String Ryan</span><br><span class="line">       6: invokespecial #10                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">       9: ldc           #11                 // String Miao</span><br><span class="line">      11: invokevirtual #12                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      14: invokevirtual #13                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">17</span>: astore_1</span><br><span class="line">      <span class="number">18</span>: aload_1</span><br><span class="line">      19: invokevirtual #3                  // Method java/lang/String.intern:()Ljava/lang/String;</span><br><span class="line">      <span class="number">22</span>: aload_1</span><br><span class="line">      <span class="number">23</span>: if_acmpne     <span class="number">30</span></span><br><span class="line">      <span class="number">26</span>: iconst_1</span><br><span class="line">      <span class="number">27</span>: goto          <span class="number">31</span></span><br><span class="line">      <span class="number">30</span>: iconst_0</span><br><span class="line">      31: invokestatic  #4                  // Method org/junit/Assert.assertTrue:(Z)V</span><br><span class="line">      <span class="number">34</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExist</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.InterruptedException</span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #8                  // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: ldc           #14                 // String ja</span><br><span class="line">       6: invokespecial #10                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">       9: ldc           #15                 // String va</span><br><span class="line">      11: invokevirtual #12                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      14: invokevirtual #13                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">17</span>: astore_1</span><br><span class="line">      <span class="number">18</span>: aload_1</span><br><span class="line">      19: invokevirtual #3                  // Method java/lang/String.intern:()Ljava/lang/String;</span><br><span class="line">      <span class="number">22</span>: aload_1</span><br><span class="line">      <span class="number">23</span>: if_acmpne     <span class="number">30</span></span><br><span class="line">      <span class="number">26</span>: iconst_1</span><br><span class="line">      <span class="number">27</span>: goto          <span class="number">31</span></span><br><span class="line">      <span class="number">30</span>: iconst_0</span><br><span class="line">      31: invokestatic  #7                  // Method org/junit/Assert.assertFalse:(Z)V</span><br><span class="line">      34: new           #8                  // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">37</span>: dup</span><br><span class="line">      38: invokespecial #16                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      41: ldc           #17                 // String in</span><br><span class="line">      43: invokevirtual #12                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      46: ldc           #18                 // String t</span><br><span class="line">      48: invokevirtual #12                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      51: invokevirtual #13                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">54</span>: astore_2</span><br><span class="line">      <span class="number">55</span>: aload_2</span><br><span class="line">      56: invokevirtual #3                  // Method java/lang/String.intern:()Ljava/lang/String;</span><br><span class="line">      <span class="number">59</span>: aload_2</span><br><span class="line">      <span class="number">60</span>: if_acmpne     <span class="number">67</span></span><br><span class="line">      <span class="number">63</span>: iconst_1</span><br><span class="line">      <span class="number">64</span>: goto          <span class="number">68</span></span><br><span class="line">      <span class="number">67</span>: iconst_0</span><br><span class="line">      68: invokestatic  #7                  // Method org/junit/Assert.assertFalse:(Z)V</span><br><span class="line">      71: ldc           #19                 // String abc</span><br><span class="line">      <span class="number">73</span>: astore_3</span><br><span class="line">      74: new           #8                  // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">77</span>: dup</span><br><span class="line">      78: invokespecial #16                 // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      81: ldc           #20                 // String ab</span><br><span class="line">      83: invokevirtual #12                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      86: ldc           #21                 // String c</span><br><span class="line">      88: invokevirtual #12                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      91: invokevirtual #13                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">94</span>: astore        <span class="number">4</span></span><br><span class="line">      <span class="number">96</span>: aload         <span class="number">4</span></span><br><span class="line">      98: invokevirtual #3                  // Method java/lang/String.intern:()Ljava/lang/String;</span><br><span class="line">     <span class="number">101</span>: aload         <span class="number">4</span></span><br><span class="line">     <span class="number">103</span>: if_acmpne     <span class="number">110</span></span><br><span class="line">     <span class="number">106</span>: iconst_1</span><br><span class="line">     <span class="number">107</span>: goto          <span class="number">111</span></span><br><span class="line">     <span class="number">110</span>: iconst_0</span><br><span class="line">     111: invokestatic  #7                  // Method org/junit/Assert.assertFalse:(Z)V</span><br><span class="line">     114: ldc2_w        #22                 // long 3600000l</span><br><span class="line">     117: invokestatic  #24                 // Method java/lang/Thread.sleep:(J)V</span><br><span class="line">     <span class="number">120</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Java在compile的时候优化了执行逻辑"><a href="#Java在compile的时候优化了执行逻辑" class="headerlink" title="Java在compile的时候优化了执行逻辑"></a>Java在compile的时候优化了执行逻辑</h3><p>我以为使用了StringBuilder可以减少性能损耗啊，然而，编译后的文件直接说no，直接给替换成拼接了:<br><img src="http://oe20lp6p0.bkt.clouddn.com/blog/2017/string/string-compile.png"></p><h2 id="1-String是如何实现Immutable的？"><a href="#1-String是如何实现Immutable的？" class="headerlink" title="1. String是如何实现Immutable的？"></a>1. String是如何实现Immutable的？</h2><p>Immutable是指String的对象实例生成后就不可以改变。相反，加入一个user类，你可以修改name，那么就不叫做Immutable。所以，String的内部属性必须是不可修改的。</p><h3 id="1-1-私有成员变量"><a href="#1-1-私有成员变量" class="headerlink" title="1.1 私有成员变量"></a>1.1 私有成员变量</h3><p>String的内部很简单，有两个私有成员变量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>而后并没有对外提供可以修改这两个属性的方法，没有set，没有build。</p><h3 id="1-2-Public的方法都是复制一份数据"><a href="#1-2-Public的方法都是复制一份数据" class="headerlink" title="1.2 Public的方法都是复制一份数据"></a>1.2 Public的方法都是复制一份数据</h3><p>String有很多public方法，要想维护这么多方法下的不可变需要付出代价。每次都将创建新的String对象。比如，这里讲一个很有迷惑性的concat方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法名上看，是拼接字符串。这样下意识以为是原对象修改了内容，所以对于<code>str2 = str.concat(&quot;abc&quot;)</code>，会认为是<code>str2==str</code>。然后熟记String不可变定律的你肯定会反对。确实不是原对象，确实<code>new</code>了新String。同样的道理，在其他String的public方法里，都将new一个新的String。因此就保证了原对象的不可变。说到这里，下面的结果是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str2 &#x3D; str.concat(&quot;&quot;);</span><br><span class="line">Assert.assertFalse(str2 &#x3D;&#x3D; str);</span><br></pre></td></tr></table></figure><p>按照String不可变的特性来理解，这里str2应该是生成的新对象，那么肯定不等于str.所以是对的，是false。面试考这种题目也是醉了，为了考验大家对String API的熟悉程度吗？看源码才知道，当拼接的内容为空的时候直接返回原对象。因此，str2==str是true。</p><h3 id="1-3-String是final的"><a href="#1-3-String是final的" class="headerlink" title="1.3 String是final的"></a>1.3 String是final的</h3><p>由于String被声明式final的，则我们不可以继承String,因此就不能通过继承来复写一些关于hashcode和value的方法。</p><h2 id="2-String为什么要设计成Immutable"><a href="#2-String为什么要设计成Immutable" class="headerlink" title="2. String为什么要设计成Immutable?"></a>2. String为什么要设计成Immutable?</h2><p>一下内容来自<a target="_blank" rel="noopener" href="http://www.kogonuso.com/2015/03/why-string-is-immutable-or-final-class.html#sthash.VgLU1mDY.dpuf">http://www.kogonuso.com/2015/03/why-string-is-immutable-or-final-class.html#sthash.VgLU1mDY.dpuf</a>. 发现百度的中文版本基本也是此文的翻译版。</p><h3 id="缓存的需要"><a href="#缓存的需要" class="headerlink" title="缓存的需要"></a>缓存的需要</h3><p>String是不可变的。因为String会被String pool缓存。因为缓存String字面量要在多个线程之间共享，一个客户端的行为会影响其他所有的客户端，所以会产生风险。如果其中一个客户端修改了内容”Test”为“TEST”, 其他客户端也会得到这个结果，但显然并想要这个结果。因为缓存字符串对性能来说至关重要，因此为了移除这种风险，String被设计成Immutable。</p><h3 id="HashMap的需要"><a href="#HashMap的需要" class="headerlink" title="HashMap的需要"></a>HashMap的需要</h3><p>HashMap在Java里太重要了，而它的key通常是String类型的。如果String是mutable，那么修改属性后，其hashcode也将改变。这样导致在HashMap中找不到原来的value。</p><h3 id="多线程中需要"><a href="#多线程中需要" class="headerlink" title="多线程中需要"></a>多线程中需要</h3><p>string的subString方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果String是可变的，即修改String的内容后，地址不变。那么当多个线程同时修改的时候，value的length是不确定的，造成不安全因素，无法得到正确的截取结果。而为了保证顺序正确，需要加<code>synchronzied</code>,但这会得到难以想象的性能问题。</p><h3 id="保证hashcode"><a href="#保证hashcode" class="headerlink" title="保证hashcode"></a>保证hashcode</h3><p>这和上条中HashMap的需要一样，不可变的好处就是hashcode不会变，可以缓存而不用计算。</p><h3 id="classloader中需要"><a href="#classloader中需要" class="headerlink" title="classloader中需要"></a>classloader中需要</h3><blockquote><p>The absolutely most important reason that String is immutable is that it is used by the class loading mechanism, and thus have profound and fundamental security aspects. Had String been mutable, a request to load “java.io.Writer” could have been changed to load “mil.vogoon.DiskErasingWriter”</p></blockquote><p>String会在加载class的时候需要，如果String可变，那么可能会修改加载中的类。</p><p>总之，安全性和String字符串常量池缓存是String被设计成不可变的主要原因。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3052442/what-is-the-difference-between-text-and-new-stringtext/3052456">https://stackoverflow.com/questions/3052442/what-is-the-difference-between-text-and-new-stringtext/3052456</a></li><li><a target="_blank" rel="noopener" href="http://www.kogonuso.com/2015/03/why-string-is-immutable-or-final-class.html#sthash.VgLU1mDY.dpuf">http://www.kogonuso.com/2015/03/why-string-is-immutable-or-final-class.html#sthash.VgLU1mDY.dpuf</a></li><li><a target="_blank" rel="noopener" href="http://rednaxelafx.iteye.com/blog/774673">http://rednaxelafx.iteye.com/blog/774673</a></li><li><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/4ee6aec39c89?from=groupmessage">http://www.jianshu.com/p/4ee6aec39c89?from=groupmessage</a></li><li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/yulei126/p/6777323.html">http://www.cnblogs.com/yulei126/p/6777323.html</a></li><li><a target="_blank" rel="noopener" href="https://blogs.oracle.com/sundararajan/querying-java-heap-with-oql">https://blogs.oracle.com/sundararajan/querying-java-heap-with-oql</a></li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">Ryan Miao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://blog.rmiao.top/2017/09/23/why-string-is-immutable/">http://blog.rmiao.top/2017/09/23/why-string-is-immutable/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.rmiao.top" target="_blank">Ryan Miao的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2017/09/29/filter-two-list/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">如何从两个List中筛选出相同的值</div></div></a></div><div class="next-post pull-right"><a href="/2017/09/18/dropwizard-feign/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">在dropwizard中使用feign,使用hystrix</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2018/02/28/ArrayList/" title="ArrayList源码阅读"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-02-28</div><div class="title">ArrayList源码阅读</div></div></a></div><div><a href="/2017/09/12/Java-ArrayList-remove/" title="Java中ArrayList remove会遇到的坑"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-09-12</div><div class="title">Java中ArrayList remove会遇到的坑</div></div></a></div><div><a href="/2017/09/29/filter-two-list/" title="如何从两个List中筛选出相同的值"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2017-09-29</div><div class="title">如何从两个List中筛选出相同的值</div></div></a></div><div><a href="/2018/02/27/hashmap/" title="HashMap原理概述"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-02-27</div><div class="title">HashMap原理概述</div></div></a></div><div><a href="/2018/07/07/java-class/" title="Java复习2-对象与类"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-07-07</div><div class="title">Java复习2-对象与类</div></div></a></div><div><a href="/2018/07/06/java-data-type/" title="Java复习1-数据类型"><img class="cover" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-07-06</div><div class="title">Java复习1-数据类型</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"><div class="author-info__name">Ryan Miao</div><div class="author-info__description">技术总结</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">93</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">60</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">43</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Ryan-Miao"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ryan-miao" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:woshimrf@126.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://www.cnblogs.com/woshimrf/" target="_blank" title="cnblogs"><i class="fas fa-folder"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/wechar.jpg" target="_blank" title="miaoxingzhe"><i class="iconfont icon-weixin"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/gongzhonghao.jpg" target="_blank" title="Ryan Miao的博客"><i class="iconfont icon-gongzhonghao"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">现在捡起来学习，不能落伍太多了。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0-String%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">0. String的内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1-%E4%B8%80%E4%BA%9B%E7%9C%9F%E5%AE%9E%E6%B5%8B%E8%AF%95%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%9F%90%E4%BA%9B%E6%8E%A8%E6%B5%8B"><span class="toc-number">2.1.</span> <span class="toc-text">0.1 一些真实测试，以及某些推测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87"><span class="toc-number">2.1.1.</span> <span class="toc-text">前期准备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E4%B8%A4%E4%B8%AA%E5%85%AC%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">这两个公式有什么用?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E5%AE%9A"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">约定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-Visual-VM"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">Java Visual VM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OQL%E8%AF%AD%E8%A8%80"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">OQL语言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-1-%E9%80%9A%E8%BF%87-%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.2.</span> <span class="toc-text">0.1.1 通过&#x3D;创建字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-2-%E9%80%9A%E8%BF%87new%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.3.</span> <span class="toc-text">0.1.2 通过new创建字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-3-%E9%80%9A%E8%BF%87%E6%8B%BC%E6%8E%A5%E5%88%9B%E9%80%A0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.4.</span> <span class="toc-text">0.1.3 通过拼接创造字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-4-%E9%92%88%E5%AF%B9%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%B8%AD%E5%B7%B2%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.5.</span> <span class="toc-text">0.1.4 针对常量池中已存在的字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%9C%A8compile%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%98%E5%8C%96%E4%BA%86%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91"><span class="toc-number">2.1.6.</span> <span class="toc-text">Java在compile的时候优化了执行逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-String%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0Immutable%E7%9A%84%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">1. String是如何实现Immutable的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.1 私有成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Public%E7%9A%84%E6%96%B9%E6%B3%95%E9%83%BD%E6%98%AF%E5%A4%8D%E5%88%B6%E4%B8%80%E4%BB%BD%E6%95%B0%E6%8D%AE"><span class="toc-number">2.2.2.</span> <span class="toc-text">1.2 Public的方法都是复制一份数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-String%E6%98%AFfinal%E7%9A%84"><span class="toc-number">2.2.3.</span> <span class="toc-text">1.3 String是final的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-String%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90Immutable"><span class="toc-number">2.3.</span> <span class="toc-text">2. String为什么要设计成Immutable?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E9%9C%80%E8%A6%81"><span class="toc-number">2.3.1.</span> <span class="toc-text">缓存的需要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%9A%84%E9%9C%80%E8%A6%81"><span class="toc-number">2.3.2.</span> <span class="toc-text">HashMap的需要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E9%9C%80%E8%A6%81"><span class="toc-number">2.3.3.</span> <span class="toc-text">多线程中需要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81hashcode"><span class="toc-number">2.3.4.</span> <span class="toc-text">保证hashcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#classloader%E4%B8%AD%E9%9C%80%E8%A6%81"><span class="toc-number">2.3.5.</span> <span class="toc-text">classloader中需要</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">2.4.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/03/11/%E7%AE%97%E6%B3%95/1.%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/" title="单链表和反转"><img src="https://cn.bing.com/th?id=OHR.EsskastanieD_ZH-CN9736686128_UHD.jpg&amp;rf=LaDigue_UHD.jpg&amp;pid=hp&amp;w=2880&amp;h=1620&amp;rs=1&amp;c=4" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="单链表和反转"></a><div class="content"><a class="title" href="/2021/03/11/%E7%AE%97%E6%B3%95/1.%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/" title="单链表和反转">单链表和反转</a><time datetime="2021-03-11T15:44:40.000Z" title="发表于 2021-03-11 23:44:40">2021-03-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/11/11/java-synchronized/" title="Java基础之Synchronized原理"><img src="https://cn.bing.com/th?id=OHR.EsskastanieD_ZH-CN9736686128_UHD.jpg&amp;rf=LaDigue_UHD.jpg&amp;pid=hp&amp;w=2880&amp;h=1620&amp;rs=1&amp;c=4" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Java基础之Synchronized原理"></a><div class="content"><a class="title" href="/2020/11/11/java-synchronized/" title="Java基础之Synchronized原理">Java基础之Synchronized原理</a><time datetime="2020-11-11T12:46:40.000Z" title="发表于 2020-11-11 20:46:40">2020-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2018/07/10/java-class-inheritance/" title="Java复习3-类的继承"><img src="https://cn.bing.com/th?id=OHR.LakotaBadlands_ZH-CN0151830089_UHD.jpg&amp;rf=LaDigue_UHD.jpg&amp;pid=hp&amp;w=2880&amp;h=1620&amp;rs=1&amp;c=4" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Java复习3-类的继承"></a><div class="content"><a class="title" href="/2018/07/10/java-class-inheritance/" title="Java复习3-类的继承">Java复习3-类的继承</a><time datetime="2018-07-10T11:58:14.000Z" title="发表于 2018-07-10 19:58:14">2018-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2018/07/07/java-class/" title="Java复习2-对象与类"><img src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Java复习2-对象与类"></a><div class="content"><a class="title" href="/2018/07/07/java-class/" title="Java复习2-对象与类">Java复习2-对象与类</a><time datetime="2018-07-07T07:27:14.000Z" title="发表于 2018-07-07 15:27:14">2018-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2018/07/06/java-data-type/" title="Java复习1-数据类型"><img src="https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Java复习1-数据类型"></a><div class="content"><a class="title" href="/2018/07/06/java-data-type/" title="Java复习1-数据类型">Java复习1-数据类型</a><time datetime="2018-07-06T09:03:26.000Z" title="发表于 2018-07-06 17:03:26">2018-07-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(https://cdn.jsdelivr.net/gh/Ryan-Miao/ryan-miao.github.io/image/default_cover.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Ryan Miao</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: '50b74dddd9c8deff00e9',
      clientSecret: 'b61654c092fbd8ab7ff6c4d0078b671b62211e23',
      repo: 'gitalk',
      owner: 'ryanmiao2',
      admin: ['ryanmiao2'],
      id: '5fce6ee91def7e1caf55652f6657e400',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="开心,美丽,大方,正直,原则,可爱,坚韧,靠谱,斜杠青年,幸运,善良,你真棒" data-fontsize="15px" data-random="false" async></script><script>function chatBtnHide(){document.getElementsByClassName("gitter-open-chat-button")[0].style.display="none"}function chatBtnShow(){document.getElementsByClassName("gitter-open-chat-button")[0].style.display="block"}((window.gitter={}).chat={}).options={room:"Ryan-Miao/blog"}</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>